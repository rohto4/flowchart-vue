{"remainingRequest":"C:\\work\\IDE\\Git\\20_work\\git_local\\flowchart-vue\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\work\\IDE\\Git\\20_work\\git_local\\flowchart-vue\\src\\components\\flowchart\\Flowchart.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\work\\IDE\\Git\\20_work\\git_local\\flowchart-vue\\src\\components\\flowchart\\Flowchart.vue","mtime":1587796142775},{"path":"C:\\work\\IDE\\Git\\20_work\\git_local\\flowchart-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\IDE\\Git\\20_work\\git_local\\flowchart-vue\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\work\\IDE\\Git\\20_work\\git_local\\flowchart-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\IDE\\Git\\20_work\\git_local\\flowchart-vue\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport {lineTo, line2} from '../../utils/svg';\nimport * as d3 from 'd3';\nimport {\n  between,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from '../../utils/math';\nimport Vue from 'vue';\nimport VueI18n from 'vue-i18n';\n\nVue.use(VueI18n);\n\nconst i18n = new VueI18n({\n  locale: 'zh',\n  messages: {\n    'en': require('../../assets/locale/en'),\n    'zh': require('../../assets/locale/zh'),\n  },\n});\n\nexport default {\n  name: 'flowchart',\n  props: {\n    nodes: {\n      type: Array,\n      default: () => [\n        {id: 1, x: 140, y: 270, name: i18n.t('message.start'), type: 'start'},\n        {id: 2, x: 540, y: 270, name: i18n.t('message.end'), type: 'end'},\n      ],\n    },\n    connections: {\n      type: Array,\n      default: () => [\n        {\n          source: {id: 1, position: 'right'},\n          destination: {id: 2, position: 'left'},\n          id: 1,\n          type: 'pass',\n        },\n      ],\n    },\n    width: {\n      type: [String, Number],\n      default: 800,\n    },\n    height: {\n      type: [String, Number],\n      default: 600,\n    },\n    locale: {\n      type: String,\n      default: 'en',\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  data() {\n    return {\n      internalNodes: [],\n      internalConnections: [],\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: {x: 0, y: 0},\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       * lines of all internalConnections\n       */\n      lines: [],\n    };\n  },\n  methods: {\n    add(x, y) {\n      if (this.readonly) {\n        return;\n      }\n      let name = i18n.t('message.new');\n      this.internalNodes.push({id: +new Date(), x: x, y: y, name: name, type: 'operation'});\n    },\n    editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit('editnode', node);\n    },\n    editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit('editconnection', connection);\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById('svg');\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= (event.deltaY / 100 / 10);\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            let tempId = +new Date();\n            let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              type: 'pass',\n              name: i18n.t('message.pass'),\n            };\n            this.internalConnections.push(conn);\n          }\n        }\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n\n        d3.selectAll('#svg .connector').classed('active', true);\n\n        let sourceOffset = this.getNodeConnectorOffset(\n            this.connectingInfo.source.id,\n            this.connectingInfo.sourcePosition,\n        );\n        let destinationPosition = this.hoveredConnector ? this.hoveredConnector.position : null;\n        this.arrowTo(sourceOffset.x, sourceOffset.y, this.cursorToChartOffset.x,\n            this.cursorToChartOffset.y, this.connectingInfo.sourcePosition, destinationPosition,\n        );\n      }\n    },\n    handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n      this.add(event.offsetX, event.offsetY);\n    },\n    handleChartMouseDown(event) {\n      this.selectionInfo = {x: event.offsetX, y: event.offsetY};\n    },\n    getConnectorPosition(node) {\n      let top = {x: node.x + 60, y: node.y};\n      let left = {x: node.x, y: node.y + 30};\n      let bottom = {x: node.x + 60, y: node.y + 60};\n      let right = {x: node.x + 120, y: node.y + 30};\n      return {left, right, top, bottom};\n    },\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          {x: that.selectionInfo.x, y: that.selectionInfo.y},\n          {x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y},\n        ]);\n        let svg = d3.select('#svg');\n        let selections = svg.select('.selection');\n        let rect;\n        if (selections.size() > 0) {\n          rect = selections;\n        } else {\n          rect = svg.append('rect');\n        }\n        rect.attr('x', edge.start.x).\n            attr('y', edge.start.y).\n            attr('width', edge.end.x - edge.start.x).\n            attr('height', edge.end.y - edge.start.y).\n            attr('class', 'selection');\n\n        that.internalNodes.forEach(item => {\n          let points = [\n            {x: item.x, y: item.y},\n            {x: item.x, y: item.y + 60},\n            {x: item.x + 120, y: item.y},\n            {x: item.x + 120, y: item.y + 60},\n          ];\n          if (points.every(point => pointRectangleIntersection(point, edge))) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach(line => {\n          let points = [\n            {x: line.sourceX, y: line.sourceY},\n            {x: line.destinationX, y: line.destinationY},\n          ];\n          if (points.every(point => pointRectangleIntersection(point, edge)) &&\n              that.currentConnections.every(item => item.id !== line.id)) {\n            let connection = that.internalConnections.filter(conn => conn.id === line.id)[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        d3.selectAll('#svg > .selection').remove();\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function(resolve) {\n        that.$nextTick(function() {\n          d3.selectAll('#svg > g.connection').remove();\n          // render lines\n          that.lines = [];\n          that.internalConnections.forEach(conn => {\n            let sourcePosition = that.getNodeConnectorOffset(\n                conn.source.id,\n                conn.source.position,\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n                conn.destination.id,\n                conn.destination.position,\n            );\n            let colors = {\n              pass: '#52c41a',\n              reject: 'red',\n            };\n            if (that.currentConnections.filter(item => item === conn).length > 0) {\n              colors = {\n                pass: '#12640a',\n                reject: 'darkred',\n              };\n            }\n            let result = that.arrowTo(\n                sourcePosition.x,\n                sourcePosition.y,\n                destinationPosition.x,\n                destinationPosition.y,\n                conn.source.position,\n                conn.destination.position,\n                colors[conn.type],\n            );\n            for (const path of result.paths) {\n              path.on('mousedown', function() {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function() {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(0, that.currentConnections.length);\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function(resolve) {\n        that.$nextTick(async function() {\n          d3.selectAll('#svg > g.node, #svg > g.guideline').remove();\n\n          // render nodes\n          that.internalNodes.forEach(node => {\n            if (that.currentNodes.filter(item => item === node).length > 0) {\n              that.renderNode(node, '#666666');\n            } else {\n              that.renderNode(node, '#bbbbbb');\n            }\n          });\n\n          resolve();\n        });\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.internalNodes.filter(item => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    guideLineTo(x1, y1, x2, y2, dash) {\n      let svg = d3.select('#svg');\n      let g = svg.append('g');\n      g.classed('guideline', true);\n      lineTo(g, x1, y1, x2, y2, 1, '#a3a3a3', dash);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n      let svg = d3.select('#svg');\n      let g = svg.append('g');\n      g.classed('connection', true);\n      line2(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || '#a3a3a3', true);\n      // a 5px cover to make mouse operation conveniently\n      return line2(g, x1, y1, x2, y2, startPosition, endPosition, 5, 'transparent', false);\n    },\n    renderNode(node, borderColor) {\n      let that = this;\n      let svg = d3.select('#svg');\n      let g = svg.append('g').attr('cursor', 'move').classed('node', true);\n\n      if (node.type !== 'start' && node.type !== 'end') {\n        // title\n        g.append('rect').\n            attr('x', node.x).\n            attr('y', node.y).\n            attr('stroke', borderColor).\n            attr('class', 'title');\n        g.append('text').\n            attr('x', node.x + 4).\n            attr('y', node.y + 15).\n            attr('class', 'unselectable').\n            text(() => node.name).\n            each(function wrap() {\n              let self = d3.select(this),\n                  textLength = self.node().getComputedTextLength(),\n                  text = self.text();\n              while (textLength > (120 - 2 * 4) && text.length > 0) {\n                text = text.slice(0, -1);\n                self.text(text + '...');\n                textLength = self.node().getComputedTextLength();\n              }\n            });\n      }\n\n      // body\n      let body = g.append('rect').attr('class', 'body');\n      if (node.type !== 'start' && node.type !== 'end') {\n        body.attr('x', node.x).attr('y', node.y + 20);\n      } else {\n        body.attr('x', node.x).attr('y', node.y).classed(node.type, true).attr('rx', 30);\n      }\n      body.attr('stroke', borderColor);\n\n      // body text\n      let text = node.type === 'start'\n          ? i18n.t('message.start')\n          : (node.type === 'end' ? i18n.t('message.end') : (\n                  (!node.approvers || node.approvers.length === 0)\n                      ? i18n.t('message.noApprover')\n                      : (\n                          node.approvers.length > 1\n                              ? `${node.approvers[0].name + i18n.t('message.etc')}`\n                              : node.approvers[0].name\n                      )\n              )\n          );\n      let bodyTextY;\n      if (node.type !== 'start' && node.type !== 'end') {\n        bodyTextY = node.y + 45;\n      } else {\n        bodyTextY = node.y + 35;\n      }\n      g.append('text').\n          attr('x', node.x + 60).\n          attr('y', bodyTextY).\n          attr('class', 'unselectable').\n          attr('text-anchor', 'middle').\n          text(function() {return text;}).each(function wrap() {\n        let self = d3.select(this),\n            textLength = self.node().getComputedTextLength(),\n            text = self.text();\n        while (textLength > (120 - 2 * 4) && text.length > 0) {\n          text = text.slice(0, -1);\n          self.text(text + '...');\n          textLength = self.node().getComputedTextLength();\n        }\n      });\n\n      let drag = d3.drag().\n          on('start', function() {\n            // handle mousedown\n            let isNotCurrentNode = that.currentNodes.filter(item => item === node).length === 0;\n            if (isNotCurrentNode) {\n              that.currentConnections.splice(0, that.currentConnections.length);\n              that.currentNodes.splice(0, that.currentNodes.length);\n              that.currentNodes.push(node);\n            }\n\n            if (that.clickedOnce) {\n              that.editNode(node);\n            } else {\n              let timer = setTimeout(function() {\n                that.clickedOnce = false;\n                clearTimeout(timer);\n              }, 300);\n              that.clickedOnce = true;\n            }\n          }).\n          on('drag', async function() {\n            if (that.readonly) {\n              return;\n            }\n\n            let zoom = parseFloat(document.getElementById('svg').style.zoom || 1);\n            for (let currentNode of that.currentNodes) {\n              currentNode.x += (d3.event.dx / zoom);\n              currentNode.y += (d3.event.dy / zoom);\n            }\n\n            let edge = that.getCurrentNodesEdge();\n            let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n            let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n            let guidelineDash = [5, 3];\n            that.internalNodes.forEach(item => {\n              if (that.currentNodes.filter(currentNode => currentNode === item).length === 0) {\n                if (item.x === expectX) {\n                  // vertical guideline\n                  if (item.y < expectY) {\n                    that.guideLineTo(item.x, item.y + 60, expectX, expectY, guidelineDash);\n                  } else {\n                    that.guideLineTo(expectX, expectY + 60, item.x, item.y, guidelineDash);\n                  }\n                }\n                if (item.y === expectY) {\n                  // horizontal guideline\n                  if (item.x < expectX) {\n                    that.guideLineTo(item.x + 120, item.y, expectX, expectY, guidelineDash);\n                  } else {\n                    that.guideLineTo(expectX + 120, expectY, item.x, item.y, guidelineDash);\n                  }\n                }\n              }\n            });\n          }).on('end', function() {\n            for (let currentNode of that.currentNodes) {\n              currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n              currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n            }\n          });\n      g.call(drag);\n      g.on('mousedown', function() {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode = that.currentNodes.filter(item => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g.append('circle').\n            attr('cx', positionElement.x).\n            attr('cy', positionElement.y).\n            attr('r', 4).\n            attr('class', 'connector');\n        connector.on('mousedown', function() {\n          d3.event.stopPropagation();\n          if (node.type === 'end' || that.readonly) {\n            return;\n          }\n          that.connectingInfo.source = node;\n          that.connectingInfo.sourcePosition = position;\n        }).on('mouseup', function() {\n          d3.event.stopPropagation();\n          if (that.connectingInfo.source) {\n            if (that.connectingInfo.source.id !== node.id) {\n              // Node can't connect to itself\n              let tempId = +new Date();\n              let conn = {\n                source: {\n                  id: that.connectingInfo.source.id,\n                  position: that.connectingInfo.sourcePosition,\n                },\n                destination: {\n                  id: node.id,\n                  position: position,\n                },\n                id: tempId,\n                type: 'pass',\n                name: i18n.t('message.pass'),\n              };\n              that.internalConnections.push(conn);\n            }\n            that.connectingInfo.source = null;\n            that.connectingInfo.sourcePosition = null;\n          }\n        }).on('mouseover', function() {\n          connector.classed('active', true);\n        }).on('mouseout', function() {\n          connector.classed('active', false);\n        });\n        connectors.push(connector);\n      }\n      g.on('mouseover', function() {\n        connectors.forEach(conn => conn.classed('active', true));\n      }).on('mouseout', function() {\n        connectors.forEach(conn => conn.classed('active', false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let edgeOfPoints = getEdgeOfPoints(this.currentNodes);\n      edgeOfPoints.x += 120;\n      edgeOfPoints.y += 60;\n      return edgeOfPoints;\n    },\n    save() {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit('save', this.internalNodes, this.internalConnections);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.internalConnections.filter(\n          item => item.source.id === node.id || item.destination.id === node.id,\n      );\n      for (let connection of connections) {\n        this.internalConnections.splice(this.internalConnections.indexOf(connection), 1);\n      }\n      this.internalNodes.splice(this.internalNodes.indexOf(node), 1);\n    },\n    removeConnection(conn) {\n      let index = this.internalConnections.indexOf(conn);\n      this.internalConnections.splice(index, 1);\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          node.x += x;\n          node.y += y;\n        }\n      }\n    },\n    init() {\n      let that = this;\n      that.internalNodes.splice(0, that.internalNodes.length);\n      that.internalConnections.splice(0, that.internalConnections.length);\n      that.nodes.forEach(node => {\n        that.internalNodes.push(JSON.parse(JSON.stringify(node)));\n      });\n      that.connections.forEach(connection => {\n        that.internalConnections.push(JSON.parse(JSON.stringify(connection)));\n      });\n    },\n  },\n  mounted() {\n    let that = this;\n    that.init();\n    document.onkeydown = function(event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById('chart')) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.internalNodes);\n            that.currentConnections.push(...that.internalConnections);\n            event.preventDefault();\n          }\n          break;\n        case 46:\n          that.remove();\n          break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {\n    i18n.locale = this.locale;\n  },\n  computed: {\n    hoveredConnector() {\n      for (const node of this.internalNodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (Math.hypot(entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y) < 10) {\n            return {position: prop, node: node};\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n            line.sourceX,\n            line.sourceY,\n            line.destinationX,\n            line.destinationY,\n            this.cursorToChartOffset.x,\n            this.cursorToChartOffset.y,\n        );\n        if (\n            distance < 5 &&\n            between(line.sourceX - 2, line.destinationX + 2, this.cursorToChartOffset.x) &&\n            between(line.sourceY - 2, line.destinationY + 2, this.cursorToChartOffset.y)\n        ) {\n          let connections = this.internalConnections.filter(item => item.id === line.id);\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return 'crosshair';\n      }\n      if (this.hoveredConnection != null) {\n        return 'pointer';\n      }\n      return null;\n    },\n  },\n  watch: {\n    internalNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    internalConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      }\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      }\n    }\n  },\n  i18n: i18n,\n};\n",{"version":3,"sources":["Flowchart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Flowchart.vue","sourceRoot":"src/components/flowchart","sourcesContent":["<template>\n    <div id=\"chart\" tabindex=\"0\"\n         :style=\"{width: isNaN(width) ? width : (width + 'px'), height: isNaN(height) ? height : (height + 'px'), cursor: cursor}\"\n         @mousemove=\"handleChartMouseMove\" @mouseup=\"handleChartMouseUp\"\n         @dblclick=\"handleChartDblClick($event)\" @mousewheel=\"handleChartMouseWheel\"\n         @mousedown=\"handleChartMouseDown($event)\">\n        <span id=\"position\" class=\"unselectable\">\n            {{ cursorToChartOffset.x + ', ' + cursorToChartOffset.y }}\n        </span>\n        <svg id=\"svg\"></svg>\n    </div>\n</template>\n<style src=\"./style.css\"></style>\n<script>\n  import {lineTo, line2} from '../../utils/svg';\n  import * as d3 from 'd3';\n  import {\n    between,\n    distanceOfPointToLine,\n    getEdgeOfPoints,\n    pointRectangleIntersection,\n  } from '../../utils/math';\n  import Vue from 'vue';\n  import VueI18n from 'vue-i18n';\n\n  Vue.use(VueI18n);\n\n  const i18n = new VueI18n({\n    locale: 'zh',\n    messages: {\n      'en': require('../../assets/locale/en'),\n      'zh': require('../../assets/locale/zh'),\n    },\n  });\n\n  export default {\n    name: 'flowchart',\n    props: {\n      nodes: {\n        type: Array,\n        default: () => [\n          {id: 1, x: 140, y: 270, name: i18n.t('message.start'), type: 'start'},\n          {id: 2, x: 540, y: 270, name: i18n.t('message.end'), type: 'end'},\n        ],\n      },\n      connections: {\n        type: Array,\n        default: () => [\n          {\n            source: {id: 1, position: 'right'},\n            destination: {id: 2, position: 'left'},\n            id: 1,\n            type: 'pass',\n          },\n        ],\n      },\n      width: {\n        type: [String, Number],\n        default: 800,\n      },\n      height: {\n        type: [String, Number],\n        default: 600,\n      },\n      locale: {\n        type: String,\n        default: 'en',\n      },\n      readonly: {\n        type: Boolean,\n        default: false,\n      },\n    },\n    data() {\n      return {\n        internalNodes: [],\n        internalConnections: [],\n        connectingInfo: {\n          source: null,\n          sourcePosition: null,\n        },\n        selectionInfo: null,\n        currentNodes: [],\n        currentConnections: [],\n        /**\n         * Mouse position(relative to chart div)\n         */\n        cursorToChartOffset: {x: 0, y: 0},\n        clickedOnce: false,\n        pathClickedOnce: false,\n        /**\n         * lines of all internalConnections\n         */\n        lines: [],\n      };\n    },\n    methods: {\n      add(x, y) {\n        if (this.readonly) {\n          return;\n        }\n        let name = i18n.t('message.new');\n        this.internalNodes.push({id: +new Date(), x: x, y: y, name: name, type: 'operation'});\n      },\n      editCurrent() {\n        if (this.currentNodes.length === 1) {\n          this.editNode(this.currentNodes[0]);\n        } else if (this.currentConnections.length === 1) {\n          this.editConnection(this.currentConnections[0]);\n        }\n      },\n      editNode(node) {\n        if (this.readonly) {\n          return;\n        }\n        this.$emit('editnode', node);\n      },\n      editConnection(connection) {\n        if (this.readonly) {\n          return;\n        }\n        this.$emit('editconnection', connection);\n      },\n      handleChartMouseWheel(event) {\n        event.stopPropagation();\n        event.preventDefault();\n        if (event.ctrlKey) {\n          let svg = document.getElementById('svg');\n          let zoom = parseFloat(svg.style.zoom || 1);\n          if (event.deltaY > 0 && zoom === 0.1) {\n            return;\n          }\n          zoom -= (event.deltaY / 100 / 10);\n          svg.style.zoom = zoom;\n        }\n      },\n      async handleChartMouseUp() {\n        if (this.connectingInfo.source) {\n          if (this.hoveredConnector) {\n            if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n              // Node can't connect to itself\n              let tempId = +new Date();\n              let conn = {\n                source: {\n                  id: this.connectingInfo.source.id,\n                  position: this.connectingInfo.sourcePosition,\n                },\n                destination: {\n                  id: this.hoveredConnector.node.id,\n                  position: this.hoveredConnector.position,\n                },\n                id: tempId,\n                type: 'pass',\n                name: i18n.t('message.pass'),\n              };\n              this.internalConnections.push(conn);\n            }\n          }\n          this.connectingInfo.source = null;\n          this.connectingInfo.sourcePosition = null;\n        }\n        if (this.selectionInfo) {\n          this.selectionInfo = null;\n        }\n      },\n      async handleChartMouseMove(event) {\n        // calc offset of cursor to chart\n        let boundingClientRect = event.currentTarget.getBoundingClientRect();\n        let actualX = event.pageX - boundingClientRect.left - window.scrollX;\n        this.cursorToChartOffset.x = Math.trunc(actualX);\n        let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n        this.cursorToChartOffset.y = Math.trunc(actualY);\n\n        if (this.connectingInfo.source) {\n          await this.renderConnections();\n\n          d3.selectAll('#svg .connector').classed('active', true);\n\n          let sourceOffset = this.getNodeConnectorOffset(\n              this.connectingInfo.source.id,\n              this.connectingInfo.sourcePosition,\n          );\n          let destinationPosition = this.hoveredConnector ? this.hoveredConnector.position : null;\n          this.arrowTo(sourceOffset.x, sourceOffset.y, this.cursorToChartOffset.x,\n              this.cursorToChartOffset.y, this.connectingInfo.sourcePosition, destinationPosition,\n          );\n        }\n      },\n      handleChartDblClick(event) {\n        if (this.readonly) {\n          return;\n        }\n        this.add(event.offsetX, event.offsetY);\n      },\n      handleChartMouseDown(event) {\n        this.selectionInfo = {x: event.offsetX, y: event.offsetY};\n      },\n      getConnectorPosition(node) {\n        let top = {x: node.x + 60, y: node.y};\n        let left = {x: node.x, y: node.y + 30};\n        let bottom = {x: node.x + 60, y: node.y + 60};\n        let right = {x: node.x + 120, y: node.y + 30};\n        return {left, right, top, bottom};\n      },\n      renderSelection() {\n        let that = this;\n        // render selection rectangle\n        if (that.selectionInfo) {\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          let edge = getEdgeOfPoints([\n            {x: that.selectionInfo.x, y: that.selectionInfo.y},\n            {x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y},\n          ]);\n          let svg = d3.select('#svg');\n          let selections = svg.select('.selection');\n          let rect;\n          if (selections.size() > 0) {\n            rect = selections;\n          } else {\n            rect = svg.append('rect');\n          }\n          rect.attr('x', edge.start.x).\n              attr('y', edge.start.y).\n              attr('width', edge.end.x - edge.start.x).\n              attr('height', edge.end.y - edge.start.y).\n              attr('class', 'selection');\n\n          that.internalNodes.forEach(item => {\n            let points = [\n              {x: item.x, y: item.y},\n              {x: item.x, y: item.y + 60},\n              {x: item.x + 120, y: item.y},\n              {x: item.x + 120, y: item.y + 60},\n            ];\n            if (points.every(point => pointRectangleIntersection(point, edge))) {\n              that.currentNodes.push(item);\n            }\n          });\n          that.lines.forEach(line => {\n            let points = [\n              {x: line.sourceX, y: line.sourceY},\n              {x: line.destinationX, y: line.destinationY},\n            ];\n            if (points.every(point => pointRectangleIntersection(point, edge)) &&\n                that.currentConnections.every(item => item.id !== line.id)) {\n              let connection = that.internalConnections.filter(conn => conn.id === line.id)[0];\n              that.currentConnections.push(connection);\n            }\n          });\n        } else {\n          d3.selectAll('#svg > .selection').remove();\n        }\n      },\n      renderConnections() {\n        let that = this;\n        return new Promise(function(resolve) {\n          that.$nextTick(function() {\n            d3.selectAll('#svg > g.connection').remove();\n            // render lines\n            that.lines = [];\n            that.internalConnections.forEach(conn => {\n              let sourcePosition = that.getNodeConnectorOffset(\n                  conn.source.id,\n                  conn.source.position,\n              );\n              let destinationPosition = that.getNodeConnectorOffset(\n                  conn.destination.id,\n                  conn.destination.position,\n              );\n              let colors = {\n                pass: '#52c41a',\n                reject: 'red',\n              };\n              if (that.currentConnections.filter(item => item === conn).length > 0) {\n                colors = {\n                  pass: '#12640a',\n                  reject: 'darkred',\n                };\n              }\n              let result = that.arrowTo(\n                  sourcePosition.x,\n                  sourcePosition.y,\n                  destinationPosition.x,\n                  destinationPosition.y,\n                  conn.source.position,\n                  conn.destination.position,\n                  colors[conn.type],\n              );\n              for (const path of result.paths) {\n                path.on('mousedown', function() {\n                  d3.event.stopPropagation();\n                  if (that.pathClickedOnce) {\n                    that.editConnection(conn);\n                  } else {\n                    let timer = setTimeout(function() {\n                      that.pathClickedOnce = false;\n                      clearTimeout(timer);\n                    }, 300);\n                    that.pathClickedOnce = true;\n                  }\n                  that.currentNodes.splice(0, that.currentNodes.length);\n                  that.currentConnections.splice(0, that.currentConnections.length);\n                  that.currentConnections.push(conn);\n                });\n              }\n              for (const line of result.lines) {\n                that.lines.push({\n                  sourceX: line.sourceX,\n                  sourceY: line.sourceY,\n                  destinationX: line.destinationX,\n                  destinationY: line.destinationY,\n                  id: conn.id,\n                });\n              }\n            });\n            resolve();\n          });\n        });\n      },\n      renderNodes() {\n        let that = this;\n        return new Promise(function(resolve) {\n          that.$nextTick(async function() {\n            d3.selectAll('#svg > g.node, #svg > g.guideline').remove();\n\n            // render nodes\n            that.internalNodes.forEach(node => {\n              if (that.currentNodes.filter(item => item === node).length > 0) {\n                that.renderNode(node, '#666666');\n              } else {\n                that.renderNode(node, '#bbbbbb');\n              }\n            });\n\n            resolve();\n          });\n        });\n      },\n      getNodeConnectorOffset(nodeId, connectorPosition) {\n        let node = this.internalNodes.filter(item => item.id === nodeId)[0];\n        return this.getConnectorPosition(node)[connectorPosition];\n      },\n      guideLineTo(x1, y1, x2, y2, dash) {\n        let svg = d3.select('#svg');\n        let g = svg.append('g');\n        g.classed('guideline', true);\n        lineTo(g, x1, y1, x2, y2, 1, '#a3a3a3', dash);\n      },\n      arrowTo(x1, y1, x2, y2, startPosition, endPosition, color) {\n        let svg = d3.select('#svg');\n        let g = svg.append('g');\n        g.classed('connection', true);\n        line2(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || '#a3a3a3', true);\n        // a 5px cover to make mouse operation conveniently\n        return line2(g, x1, y1, x2, y2, startPosition, endPosition, 5, 'transparent', false);\n      },\n      renderNode(node, borderColor) {\n        let that = this;\n        let svg = d3.select('#svg');\n        let g = svg.append('g').attr('cursor', 'move').classed('node', true);\n\n        if (node.type !== 'start' && node.type !== 'end') {\n          // title\n          g.append('rect').\n              attr('x', node.x).\n              attr('y', node.y).\n              attr('stroke', borderColor).\n              attr('class', 'title');\n          g.append('text').\n              attr('x', node.x + 4).\n              attr('y', node.y + 15).\n              attr('class', 'unselectable').\n              text(() => node.name).\n              each(function wrap() {\n                let self = d3.select(this),\n                    textLength = self.node().getComputedTextLength(),\n                    text = self.text();\n                while (textLength > (120 - 2 * 4) && text.length > 0) {\n                  text = text.slice(0, -1);\n                  self.text(text + '...');\n                  textLength = self.node().getComputedTextLength();\n                }\n              });\n        }\n\n        // body\n        let body = g.append('rect').attr('class', 'body');\n        if (node.type !== 'start' && node.type !== 'end') {\n          body.attr('x', node.x).attr('y', node.y + 20);\n        } else {\n          body.attr('x', node.x).attr('y', node.y).classed(node.type, true).attr('rx', 30);\n        }\n        body.attr('stroke', borderColor);\n\n        // body text\n        let text = node.type === 'start'\n            ? i18n.t('message.start')\n            : (node.type === 'end' ? i18n.t('message.end') : (\n                    (!node.approvers || node.approvers.length === 0)\n                        ? i18n.t('message.noApprover')\n                        : (\n                            node.approvers.length > 1\n                                ? `${node.approvers[0].name + i18n.t('message.etc')}`\n                                : node.approvers[0].name\n                        )\n                )\n            );\n        let bodyTextY;\n        if (node.type !== 'start' && node.type !== 'end') {\n          bodyTextY = node.y + 45;\n        } else {\n          bodyTextY = node.y + 35;\n        }\n        g.append('text').\n            attr('x', node.x + 60).\n            attr('y', bodyTextY).\n            attr('class', 'unselectable').\n            attr('text-anchor', 'middle').\n            text(function() {return text;}).each(function wrap() {\n          let self = d3.select(this),\n              textLength = self.node().getComputedTextLength(),\n              text = self.text();\n          while (textLength > (120 - 2 * 4) && text.length > 0) {\n            text = text.slice(0, -1);\n            self.text(text + '...');\n            textLength = self.node().getComputedTextLength();\n          }\n        });\n\n        let drag = d3.drag().\n            on('start', function() {\n              // handle mousedown\n              let isNotCurrentNode = that.currentNodes.filter(item => item === node).length === 0;\n              if (isNotCurrentNode) {\n                that.currentConnections.splice(0, that.currentConnections.length);\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentNodes.push(node);\n              }\n\n              if (that.clickedOnce) {\n                that.editNode(node);\n              } else {\n                let timer = setTimeout(function() {\n                  that.clickedOnce = false;\n                  clearTimeout(timer);\n                }, 300);\n                that.clickedOnce = true;\n              }\n            }).\n            on('drag', async function() {\n              if (that.readonly) {\n                return;\n              }\n\n              let zoom = parseFloat(document.getElementById('svg').style.zoom || 1);\n              for (let currentNode of that.currentNodes) {\n                currentNode.x += (d3.event.dx / zoom);\n                currentNode.y += (d3.event.dy / zoom);\n              }\n\n              let edge = that.getCurrentNodesEdge();\n              let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n              let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n              let guidelineDash = [5, 3];\n              that.internalNodes.forEach(item => {\n                if (that.currentNodes.filter(currentNode => currentNode === item).length === 0) {\n                  if (item.x === expectX) {\n                    // vertical guideline\n                    if (item.y < expectY) {\n                      that.guideLineTo(item.x, item.y + 60, expectX, expectY, guidelineDash);\n                    } else {\n                      that.guideLineTo(expectX, expectY + 60, item.x, item.y, guidelineDash);\n                    }\n                  }\n                  if (item.y === expectY) {\n                    // horizontal guideline\n                    if (item.x < expectX) {\n                      that.guideLineTo(item.x + 120, item.y, expectX, expectY, guidelineDash);\n                    } else {\n                      that.guideLineTo(expectX + 120, expectY, item.x, item.y, guidelineDash);\n                    }\n                  }\n                }\n              });\n            }).on('end', function() {\n              for (let currentNode of that.currentNodes) {\n                currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n                currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n              }\n            });\n        g.call(drag);\n        g.on('mousedown', function() {\n          // handle ctrl+mousedown\n          if (!d3.event.ctrlKey) {\n            return;\n          }\n          let isNotCurrentNode = that.currentNodes.filter(item => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentNodes.push(node);\n          } else {\n            that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n          }\n        });\n\n        let connectors = [];\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let position in connectorPosition) {\n          let positionElement = connectorPosition[position];\n          let connector = g.append('circle').\n              attr('cx', positionElement.x).\n              attr('cy', positionElement.y).\n              attr('r', 4).\n              attr('class', 'connector');\n          connector.on('mousedown', function() {\n            d3.event.stopPropagation();\n            if (node.type === 'end' || that.readonly) {\n              return;\n            }\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          }).on('mouseup', function() {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = +new Date();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  type: 'pass',\n                  name: i18n.t('message.pass'),\n                };\n                that.internalConnections.push(conn);\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          }).on('mouseover', function() {\n            connector.classed('active', true);\n          }).on('mouseout', function() {\n            connector.classed('active', false);\n          });\n          connectors.push(connector);\n        }\n        g.on('mouseover', function() {\n          connectors.forEach(conn => conn.classed('active', true));\n        }).on('mouseout', function() {\n          connectors.forEach(conn => conn.classed('active', false));\n        });\n      },\n      getCurrentNodesEdge() {\n        let edgeOfPoints = getEdgeOfPoints(this.currentNodes);\n        edgeOfPoints.x += 120;\n        edgeOfPoints.y += 60;\n        return edgeOfPoints;\n      },\n      save() {\n        if (this.readonly) {\n          return;\n        }\n        this.$emit('save', this.internalNodes, this.internalConnections);\n      },\n      async remove() {\n        if (this.readonly) {\n          return;\n        }\n        if (this.currentConnections.length > 0) {\n          for (let conn of this.currentConnections) {\n            this.removeConnection(conn);\n          }\n          this.currentConnections.splice(0, this.currentConnections.length);\n        }\n        if (this.currentNodes.length > 0) {\n          for (let node of this.currentNodes) {\n            this.removeNode(node);\n          }\n          this.currentNodes.splice(0, this.currentNodes.length);\n        }\n      },\n      removeNode(node) {\n        let connections = this.internalConnections.filter(\n            item => item.source.id === node.id || item.destination.id === node.id,\n        );\n        for (let connection of connections) {\n          this.internalConnections.splice(this.internalConnections.indexOf(connection), 1);\n        }\n        this.internalNodes.splice(this.internalNodes.indexOf(node), 1);\n      },\n      removeConnection(conn) {\n        let index = this.internalConnections.indexOf(conn);\n        this.internalConnections.splice(index, 1);\n      },\n      moveCurrentNode(x, y) {\n        if (this.currentNodes.length > 0 && !this.readonly) {\n          for (let node of this.currentNodes) {\n            node.x += x;\n            node.y += y;\n          }\n        }\n      },\n      init() {\n        let that = this;\n        that.internalNodes.splice(0, that.internalNodes.length);\n        that.internalConnections.splice(0, that.internalConnections.length);\n        that.nodes.forEach(node => {\n          that.internalNodes.push(JSON.parse(JSON.stringify(node)));\n        });\n        that.connections.forEach(connection => {\n          that.internalConnections.push(JSON.parse(JSON.stringify(connection)));\n        });\n      },\n    },\n    mounted() {\n      let that = this;\n      that.init();\n      document.onkeydown = function(event) {\n        switch (event.keyCode) {\n          case 37:\n            that.moveCurrentNode(-10, 0);\n            break;\n          case 38:\n            that.moveCurrentNode(0, -10);\n            break;\n          case 39:\n            that.moveCurrentNode(10, 0);\n            break;\n          case 40:\n            that.moveCurrentNode(0, 10);\n            break;\n          case 27:\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            break;\n          case 65:\n            if (document.activeElement === document.getElementById('chart')) {\n              that.currentNodes.splice(0, that.currentNodes.length);\n              that.currentConnections.splice(0, that.currentConnections.length);\n              that.currentNodes.push(...that.internalNodes);\n              that.currentConnections.push(...that.internalConnections);\n              event.preventDefault();\n            }\n            break;\n          case 46:\n            that.remove();\n            break;\n          default:\n            break;\n        }\n      };\n    },\n    created() {\n      i18n.locale = this.locale;\n    },\n    computed: {\n      hoveredConnector() {\n        for (const node of this.internalNodes) {\n          let connectorPosition = this.getConnectorPosition(node);\n          for (let prop in connectorPosition) {\n            let entry = connectorPosition[prop];\n            if (Math.hypot(entry.x - this.cursorToChartOffset.x,\n                entry.y - this.cursorToChartOffset.y) < 10) {\n              return {position: prop, node: node};\n            }\n          }\n        }\n        return null;\n      },\n      hoveredConnection() {\n        for (const line of this.lines) {\n          let distance = distanceOfPointToLine(\n              line.sourceX,\n              line.sourceY,\n              line.destinationX,\n              line.destinationY,\n              this.cursorToChartOffset.x,\n              this.cursorToChartOffset.y,\n          );\n          if (\n              distance < 5 &&\n              between(line.sourceX - 2, line.destinationX + 2, this.cursorToChartOffset.x) &&\n              between(line.sourceY - 2, line.destinationY + 2, this.cursorToChartOffset.y)\n          ) {\n            let connections = this.internalConnections.filter(item => item.id === line.id);\n            return connections.length > 0 ? connections[0] : null;\n          }\n        }\n        return null;\n      },\n      cursor() {\n        if (this.connectingInfo.source || this.hoveredConnector) {\n          return 'crosshair';\n        }\n        if (this.hoveredConnection != null) {\n          return 'pointer';\n        }\n        return null;\n      },\n    },\n    watch: {\n      internalNodes: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.renderNodes();\n          this.renderConnections();\n        },\n      },\n      internalConnections: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.renderConnections();\n        },\n      },\n      selectionInfo: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.renderSelection();\n        },\n      },\n      currentNodes: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.renderNodes();\n        },\n      },\n      currentConnections: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.renderConnections();\n        },\n      },\n      cursorToChartOffset: {\n        immediate: true,\n        deep: true,\n        handler() {\n          if (this.selectionInfo) {\n            this.renderSelection();\n          }\n        },\n      },\n      connectingInfo: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.renderConnections();\n        },\n      },\n      nodes: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.init();\n        }\n      },\n      connections: {\n        immediate: true,\n        deep: true,\n        handler() {\n          this.init();\n        }\n      }\n    },\n    i18n: i18n,\n  };\n</script>\n"]}]}